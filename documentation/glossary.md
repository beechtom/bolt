# Glossary

Definitions of terms used in Bolt documentation.

## agent

The Puppet agent software package, also known as `puppet-agent`.

## apply

## catalog

A catalog is a file that describes the desired state of each managed resource on
a target. It is a compilation of all the resources that the Puppet agent applies
to a given target, as well as the relationships between those resources.

Catalogs are compiled by Bolt from manifests and agent-provided data during an
apply. Bolt then serves the compiled catalog to the agent on a target.

Unlike the manifests from which they are compiled, catalogs don't contain any
conditional logic or functions. They are unambiguous, relevant to only a
specific target, and generated by a target.

ðŸ“– **Related information**

- [Catalog compilation](https://puppet.com/docs/puppet/latest/subsystem_catalog_compilation.html#subsystem_catalog_compilation)

## fact

A fact is a piece of information about a target, such as its hostname, IP
address, or operating system.

## Facter

Facter is a system inventory tool. Facter reads facts about a target, such as
its hostname, IP address, and operating system, and makes them available to
Bolt.

Facter includes many built-in facts, and you can view their names and values for
a particular node by running `facter` on the target's command line.

## feature

## function

## group

A group is a set of targets and other groups in the inventory and their
associated configuration. Groups provide a way for you to refer to targets
that share a common trait by a simple, human-readable name.

ðŸ“– **Related information**

- [Inventory files](inventory_file_v2.md)

## Hiera

## inventory

The inventory describes the targets that you run Bolt commands on, along with
any data and configuration for the targets. Targets in an inventory can belong
to one or more groups, allowing you to share data and configuration across
multiple targets and to specify multiple targets for your Bolt commands without
the need to list each target individually.

In most cases, Bolt loads the inventory from an inventory file in your Bolt
project. The inventory file is a YAML file named `inventory.yaml`. Because Bolt
loads the inventory file from a Bolt project, you must have an existing project
configuration file named `bolt-project.yaml` alongside the inventory file.

ðŸ“– **Related information**

- [Inventory files](inventory_file_v2.md)
- [inventory.yaml fields](bolt_inventory_reference.md)

## log

## manifest

## module

Modules are shareable, reusable packages of Puppet content. They can include
tasks, plans, functions, and other types of content that you can use in your
project. You can download and install modules to your project from the Puppet
Forge or write your own modules. Bolt also ships with several helpful modules
pre-installed that are available to all of your projects.

Bolt makes it easy to manage the modules that your project depends on. You can
use Bolt commands to install a project's modules, add new modules to a project,
and view the modules that are available to the project.

ðŸ“– **Related information**

- [Managing modules in Bolt projects](managing_modules.md)
- [Installing modules](bolt_installing_modules.md)
- [Module structure](module_structure.md)

## modulepath

The modulepath is an ordered list of directories that Bolt loads modules from.
When Bolt runs a command, it automatically loads modules from the modulepath.

While Bolt has a default modulepath, you can also configure your own modulepath,
which can include directories within the project or directories elsewhere on
your system. Regardless of whether your project uses a default or configured
modulepath, Bolt automatically adds directories to the modulepath. This includes
modules containing core Bolt content, which is added to the beginning of the
modulepath, and bundled content, which is added to the end of the modulepath.

Modules loaded from a directory listed earlier in the modulepath take precedence
over modules with the same name loaded from a directory later in the modulepath.
Bolt will not warn or error when two modules share a name and instead will
ignore modules with a lower precedence.

## plan

A set of actions that can be combined with other logic.

Plans allow you to do complex operations, such as running multiple actions with
one command, computing values for the input for an action, or running certain
actions based on the results of another action.

Plans can be written in YAML or in the Puppet language, and can be packaged as
part of a module or project.

ðŸ“– **Related information**

- [Inspecting plans](inspecting_plans.md)
- [Running plans](bolt_running_plans.md)
- [Writing plans in YAML](writing_yaml_plans.md)
- [Writing plans in the Puppet language](writing_plans.md)

## plugin

## project

A Bolt project is a directory that serves as the launching point for Bolt and
allows you to create a shareable orchestration application. Projects typically
include a project configuration file, an inventory file, and any content you use
in your project workflow, such as tasks and plans.

When you run Bolt, it runs in the context of a project. If the directory you run
Bolt from is not a project, Bolt attempts to find a project by traversing the
parent directories. If Bolt is unable to find a project, it runs from the
default project, located at `~/.puppetlabs/bolt`.

A directory is only considered a Bolt project when it has a project
configuration file named `bolt-project.yaml`. Bolt doesn't load project data and
content, including inventory files, unless the data and content are part of a
project.

ðŸ“– **Related information**

- [Bolt projects](projects.md)
- [bolt-project.yaml options](bolt_project_reference.md)

## puppetfile

## target

A target is a device that Bolt connects to and runs actions on. Targets can be
physical, such as servers, or virtual, such as containers or virtual machines.

ðŸ“– **Related information**

- [Inventory files](inventory_file_v2.md)

## task

A task is a single action that you run on targets. You use tasks to make
as-needed changes to remote systems.

Tasks are similar to scripts and can be written in any programming language that
can run on the targets, such as Bash, PowerShell, and Python. Tasks are packaged
within modules or projects, so you can reuse, download and share tasks. Tasks
also have metadata that describes the task, validates input, and controls how
the task runner executes the task.

ðŸ“– **Related information**

- [Inspecting tasks](inspecting_tasks.md)
- [Running tasks](bolt_running_tasks.md)
- [Writing tasks](writing_tasks.md)

## transport

## type

## var
